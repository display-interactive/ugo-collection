<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-selector/core-selector.html">

<polymer-element name="ugo-collection" attributes="selected addText createText removeText prototypeAttribute prototypeProperty itemSelector itemAttribute itemSelectedClass errorClass nestedErrorSelector">
    <template>
        <link rel="stylesheet" href="ugo-collection.css" shim-shadowdom>
        <div class="ugo-collection-menu">
            <core-selector id="list" class="ugo-collection-list" selected="{{selected}}">
                <template repeat="{{item, index in menuItems}}">
                    <div data-error?="{{item.hasError}}">
                        {{item.title}}
                        <button type="button" on-tap="{{removeItem}}" ugo-collection-index="{{index}}">{{removeText}}</button>
                        <div class="ugo-collection-arrow"></div>
                    </div>
                </template>
            </core-selector>
            <button id="add" disabled?="{{ disabledAdd }}" on-tap="{{addItem}}">{{addText}}</button>
        </div>
        <content id="items" select="{{itemSelector}}"></content>
    </template>
    <script>
        Polymer('ugo-collection', {

            /**
             * selected index
             *
             * @type {Number}
             */
            selected: -1,

            /**
             * Text on add button
             * @type {String}
             */
            addText: 'add',

            /**
             * Text on remove buttons
             * @type {String}
             */
            removeText: 'remove',

            /**
             * Text on create
             *
             * @type {String}
             */
            createText: 'Editing...',

            prototypeAttribute: 'data-prototype',
            prototypeProperty: '__name__',
            itemSelector: '[ugo-collection-item]',
            itemAttribute: 'ugo-collection-item',
            itemSelectedClass: 'ugo-collection-selected',

            /**
             * class used to ma
             */
            errorClass: 'has-error',
            nestedErrorSelector: '.has-error',

            /**
             * Property use to disable the add button
             * @type {Boolean}
             */
            disabledAdd: false,

            /**
             * Array containing menus items
             * @return {Array}
             */
            menuItems: [],

            /**
             * init
             */
            ready: function() {
                this.index = this.items.length;
                this.prev = null;
                this.resumerChangeListener = this.onResumerChangeHandler.bind(this);
            },

            /**
             * Rebuild menu on dom ready
             */
            domReady: function() {
                var selectedChanged = false;
                this.menuItems = [];
                [].forEach.call(this.items, function(item, index) {
                    var hasError = this.hasErrorClass(index);
                    this.menuItems.push({title: this.getTitle(item, index), hasError: hasError});
                    if (hasError && !selectedChanged) {
                        this.selected = index;
                        selectedChanged = true;
                    }
                }.bind(this));
            },

            /**
             * Add item to the collection
             */
            addItem: function() {
                //if active item is not valid: avoid addItem
                if (this.items[this.selected] != undefined && !this.isValid(this.selected)) return;

                var prototype = this.getAttribute(this.prototypeAttribute);

                //get prototype markup, parse it
                var re = new RegExp(this.prototypeProperty, 'g');
                var item = this.createNodeFromString(prototype.replace(re, this.index));

                //increment index
                this.index += 1;

                //add to html and add display it
                this.appendChild(item);
                item.classList.add(this.errorClass);
                this.menuItems.push({title: this.createText, hasError: true});
                //select last
                this.selected = this.items.length -1;
                this.disabledAdd = true;
            },

            /**
             * Remove item from the collection
             */
            removeItem: function(event) {
                var index = event.target.getAttribute('ugo-collection-index');
                if (!index) return;

                var item = this.items[index];
                item.parentNode.removeChild(item);
                item.classList.remove(this.errorClass);

                //delete menu items
                delete this.menuItems[index];
                //rebase keys
                var newArr = [];
                this.menuItems.forEach(function (item) {
                    newArr.push(item);
                });
                this.menuItems = newArr;

                //set selected to -1 if the deleted item is selected
                if (this.selected === parseInt(index)) {
                    this.selected = -1;
                    this.disabledAdd = false;
                }

                event.stopPropagation();
            },

            /**
             * Returns an array of all items.
             *
             * @property items
             */
            get items() {
                return this.$.items.getDistributedNodes();
            },

            /**
             * on selected property changed
             * @private
             */
            selectedChanged: function(oldValue, newValue) {
                if (-1 == oldValue || this.isValid(oldValue)) {
                    var selectedFound = false;
                    for (var i = 0; i < this.items.length; i++) {
                        //remove all error class

                        if (i == this.selected) {
                            selectedFound = true;
                            this.items[i].classList.add(this.itemSelectedClass);
                            this.addListeners(this.items[i]);
                        } else {
                            this.items[i].classList.remove(this.itemSelectedClass);
                            this.removeListeners(this.items[i]);
                        }
                    }

                    //if we didn't selected an item we set selected to -1
                    if (!selectedFound) {
                        this.selected = -1;
                    }

                    this.prev = null; //no more prevs
                } else if (this.prev !== this.selected && undefined != this.items[oldValue]) {
                    //we reset the selected value because the active item is invalid
                    //the store the oldValue to avoid infinite loop
                    //because this.selected = xxx trigger selectedChanged()
                    this.items[oldValue].classList.add(this.errorClass);
                    this.selected = oldValue;
                    this.prev = oldValue;
                }
            },

            /**
             * Menu display or not with menuItems changes
             */
            menuItemsChanged: function() {
                this.$.list.style.display = this.menuItems.length > 0 ? 'block' : 'none';
            },

            /**
             * Create a Node from a string
             *
             * @param {string} str
             * @returns {Node}
             * @private
             */
            createNodeFromString: function(str) {
                var div = document.createElement('div');
                div.innerHTML = str;

                return div.firstChild;
            },

            /**
             * Check if the active item is valid
             *
             * @return {Boolean}
             * @private
             */
            isValid: function(oldValue) {
                var item = this.items[oldValue];
                if (!item) return false;

                var elements = item.querySelectorAll('input, textarea, select');

                var isValid = true;
                [].forEach.call(elements, function(element) {
                    if (!element.validity.valid) {
                        isValid = false;
                    }
                });

                return isValid;
            },

            /**
             * Check if given item has error class so that it's marked as errored externaly
             *
             * @private
             */
            hasErrorClass: function(value) {
                var item = this.items[value];
                if (!item) return false;

                if (item.classList.contains('has-error') || item.querySelectorAll(this.nestedErrorSelector).length > 0)
                    return true;

                return false;
            },


            /**
             * Get resume for ugo-resumer if exists or get Index
             *
             * @return {String}
             */
            getTitle: function(item, index) {
                var resumer = item.querySelector('ugo-resumer');
                if (resumer && resumer.resume != undefined && resumer.resume) {
                    return resumer.resume;
                } else {
                    return index;
                }
            },

            /**
             * Add listeners
             * @private
             */
            addListeners: function(item) {
                var resumer = item.querySelector('ugo-resumer');
                if (resumer) {
                    Polymer.addEventListener(resumer, 'ugo-resumer-change', this.resumerChangeListener);
                }
            },

            /**
             * Remove listeners
             * @private
             */
            removeListeners: function(item) {
                var resumer = item.querySelector('ugo-resumer');
                if (resumer) {
                    Polymer.removeEventListener(resumer, 'ugo-resumer-change', this.resumerChangeListener);
                }
            },

            /**
             * ugo-resumer-change to update list
             * @param event
             */
            onResumerChangeHandler: function(event) {
                var menuItem = this.menuItems[this.selected];
                if (undefined != menuItem) {
                    menuItem.title = this.getTitle(event.target.parentNode, this.selected);

                    if (this.isValid(this.selected)) {
                        this.disabledAdd = false;
                        event.target.parentNode.classList.remove(this.errorClass);
                        menuItem.hasError = false;
                    } else {
                        this.disabledAdd = true;
                        event.target.parentNode.classList.add(this.errorClass);
                        menuItem.hasError = true;
                    }
                }
            }
        });
    </script>
</polymer-element>